<!doctype html>



































<html
  class="not-ready lg:text-base"
  style="--bg: #faf8f1"
  lang="en-us"
>
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-TJGSXWPJT4"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-TJGSXWPJT4');
        }
      </script>
    
  


  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>How to cache your functions the right way? - bhuv&#39;s notebook</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="&ldquo;Benchmarking&rdquo;—a word that either kicks off an experiment or follows a bold new proposal. But when you&rsquo;re dealing with massive datasets, the benchmarking and evaluation functions can take their sweet time. What&rsquo;s a reasonable person to do? Simple: hit run, grab a coffee, lunch, or, if you&rsquo;re really daring, take a nap. Yet, the horror of returning to find your entire experiment crashed because one row was invalid, an API hit its rate limit, or some sneaky corner case reared its ugly head is all too real." />
  <meta name="author" content="Bhuvanesh Sridharan" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="http://localhost:1313/main.min.css" />

  
  
  
  
  
  <link rel="preload" as="image" href="http://localhost:1313/theme.svg" />

  
  
  
  
  

  
  
  <link rel="preload" as="image" href="http://localhost:1313/twitter.svg" />
  
  <link rel="preload" as="image" href="http://localhost:1313/github.svg" />
  
  <link rel="preload" as="image" href="http://localhost:1313/linkedin.svg" />
  
  

  
  
  <script
    defer
    src="http://localhost:1313/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  
  

  
  <link rel="icon" href="http://localhost:1313/favicon.ico" />
  <link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.131.0">

  
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold"
      href="http://localhost:1313/"
      >bhuv&#39;s notebook</a
    >
    <div
      class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
      document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    
    <nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6">
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/about"
        >About</a
      >
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/publications"
        >Publications</a
      >
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/posts"
        >ThoughtDrops</a
      >
      
    </nav>
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href="https://twitter.com/_bhuvanesh_"
        target="_blank"
        rel="me"
      >
        twitter
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/bhuvanesh09"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./linkedin.svg)"
        href="https://linkedin.com/in/bhuvanesh-sridharan-40887b19b/"
        target="_blank"
        rel="me"
      >
        linkedin
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"
    >
      
      
      
      

<article>
  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">How to cache your functions the right way?</h1>

    
    <div class="text-sm antialiased opacity-60">
      
      <time>Aug 4, 2024</time>
      
      
      
      
    </div>
    
  </header>

  <section><p>&ldquo;Benchmarking&rdquo;—a word that either kicks off an experiment or follows a bold new proposal. But when you&rsquo;re dealing with massive datasets, the benchmarking and evaluation functions can take their sweet time. What&rsquo;s a reasonable person to do? Simple: hit run, grab a coffee, lunch, or, if you&rsquo;re really daring, take a nap. Yet, the horror of returning to find your entire experiment crashed because one row was invalid, an API hit its rate limit, or some sneaky corner case reared its ugly head is all too real.</p>
<p>Once bitten, twice shy—we scramble for makeshift solutions, like saving outputs to files and reloading them. Sure, it works, but doing it for each new experiment or API, each with its unique data quirks, quickly turns into a chore. And let&rsquo;s not even get started on the rampant chaos when dealing with asynchronous functions and multiple coroutines.</p>
<p>Here&rsquo;s where things get interesting: in many of these scenarios, both inputs and outputs are immutable, opening the door for a smarter, sleeker way to generalize our caching, no matter the data type. Enter Python&rsquo;s decorators, they allow us to add caching functionality to our functions without mucking around with their insides in an elegant way.</p>
<p>In this short write up, we&rsquo;ll build a caching decorator from scratch, gradually improving it to handle more complex scenarios.</p>
<h2 id="version-1-basic-caching-with-a-dictionary">Version 1: Basic Caching with a Dictionary</h2>
<p>Let&rsquo;s start with a simple caching decorator that stores results in a dictionary:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> functools <span style="color:#f92672">import</span> wraps
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">cache</span>(func):
</span></span><span style="display:flex;"><span>    cache_dict <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@wraps</span>(func)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> args <span style="color:#f92672">in</span> cache_dict:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> cache_dict[args]
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> func(<span style="color:#f92672">*</span>args)
</span></span><span style="display:flex;"><span>        cache_dict[args] <span style="color:#f92672">=</span> result
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> wrapper
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Usage example</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@cache</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">expensive_function</span>(x, y):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Simulate an expensive operation</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(expensive_function(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>))  <span style="color:#75715e"># Takes 2 seconds</span>
</span></span><span style="display:flex;"><span>print(expensive_function(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>))  <span style="color:#75715e"># Returns immediately</span>
</span></span></code></pre></div><p>This basic version works well for simple cases, but it has some limitations:</p>
<ol>
<li>It only works with positional arguments.</li>
<li>The cache persists only for the lifetime of the program.</li>
<li>There&rsquo;s no way to bypass the cache if needed.</li>
<li>It doesn&rsquo;t support asynchronous functions.</li>
</ol>
<p>Let&rsquo;s address these issues one by one.</p>
<h2 id="version-2-supporting-both-args-and-kwargs">Version 2: Supporting Both Args and Kwargs</h2>
<p>To support both positional and keyword arguments, we need to create a cache key that includes both:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">cache</span>(func):
</span></span><span style="display:flex;"><span>    cache_dict <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@wraps</span>(func)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Create a cache key from both args and kwargs</span>
</span></span><span style="display:flex;"><span>        key <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>dumps((args, sorted(kwargs<span style="color:#f92672">.</span>items())), sort_keys<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> key <span style="color:#f92672">in</span> cache_dict:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> cache_dict[key]
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>        cache_dict[key] <span style="color:#f92672">=</span> result
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> wrapper
</span></span></code></pre></div><p>Now our decorator supports both types of arguments. However, the cache still doesn&rsquo;t persist between program runs, and we might want to limit the number of cached entries to prevent memory issues.</p>
<h2 id="version-3-persistent-cache-with-entry-limit">Version 3: Persistent Cache with Entry Limit</h2>
<p>Let&rsquo;s improve our decorator to store the cache in a file and limit the number of entries:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> json
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">cache</span>(entries_limit<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorator</span>(func):
</span></span><span style="display:flex;"><span>        cache_file <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>func<span style="color:#f92672">.</span>__name__<span style="color:#e6db74">}</span><span style="color:#e6db74">_cache.json&#34;</span>
</span></span><span style="display:flex;"><span>        cache_dict <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>        new_entries <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Load cache from file if it exists</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>exists(cache_file):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">with</span> open(cache_file, <span style="color:#e6db74">&#39;r&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>                cache_dict <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">save_cache</span>():
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">with</span> open(cache_file, <span style="color:#e6db74">&#39;w&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>                json<span style="color:#f92672">.</span>dump(cache_dict, f)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">@wraps</span>(func)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">nonlocal</span> new_entries
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            key <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>dumps((args, sorted(kwargs<span style="color:#f92672">.</span>items())), sort_keys<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> key <span style="color:#f92672">in</span> cache_dict:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> cache_dict[key]
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            result <span style="color:#f92672">=</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>            cache_dict[key] <span style="color:#f92672">=</span> result
</span></span><span style="display:flex;"><span>            new_entries <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Save cache every entries_limit new entries</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> new_entries <span style="color:#f92672">&gt;=</span> entries_limit:
</span></span><span style="display:flex;"><span>                save_cache()
</span></span><span style="display:flex;"><span>                new_entries <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> wrapper
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> decorator
</span></span></code></pre></div><p>This version addresses the persistence issue and adds an entry limit. However, there might be cases where we want to bypass the cache and force a recalculation.</p>
<h2 id="version-4-allowing-cache-bypass">Version 4: Allowing Cache Bypass</h2>
<p>Let&rsquo;s add an option to bypass the cache:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">cache</span>(entries_limit<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorator</span>(func):
</span></span><span style="display:flex;"><span>        cache_file <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>func<span style="color:#f92672">.</span>__name__<span style="color:#e6db74">}</span><span style="color:#e6db74">_cache.json&#34;</span>
</span></span><span style="display:flex;"><span>        cache_dict <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>        new_entries <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>exists(cache_file):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">with</span> open(cache_file, <span style="color:#e6db74">&#39;r&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>                cache_dict <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">save_cache</span>():
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">with</span> open(cache_file, <span style="color:#e6db74">&#39;w&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>                json<span style="color:#f92672">.</span>dump(cache_dict, f)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">@wraps</span>(func)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, _bypass_cache<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">nonlocal</span> new_entries
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># If _bypass_cache is True, run the function without caching</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> _bypass_cache:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Create a cache key from both args and kwargs</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Exclude _bypass_cache from the key</span>
</span></span><span style="display:flex;"><span>            key <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>dumps((args, sorted((k, v) <span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> kwargs<span style="color:#f92672">.</span>items() <span style="color:#66d9ef">if</span> k <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;_bypass_cache&#39;</span>)), sort_keys<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> key <span style="color:#f92672">in</span> cache_dict:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> cache_dict[key]
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            result <span style="color:#f92672">=</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>            cache_dict[key] <span style="color:#f92672">=</span> result
</span></span><span style="display:flex;"><span>            new_entries <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> new_entries <span style="color:#f92672">&gt;=</span> entries_limit:
</span></span><span style="display:flex;"><span>                save_cache()
</span></span><span style="display:flex;"><span>                new_entries <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> wrapper
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> decorator
</span></span></code></pre></div><p>Now we can bypass the cache when needed by passing <code>_bypass_cache=True</code>. The last major improvement we can make is to support asynchronous functions.</p>
<h2 id="version-5-supporting-async-functions">Version 5: Supporting Async Functions</h2>
<p>To support async functions, we need to modify our decorator to work with coroutines:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> asyncio
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">cache</span>(entries_limit<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decorator</span>(func):
</span></span><span style="display:flex;"><span>        cache_file <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>func<span style="color:#f92672">.</span>__name__<span style="color:#e6db74">}</span><span style="color:#e6db74">_cache.json&#34;</span>
</span></span><span style="display:flex;"><span>        cache_dict <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>        new_entries <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>exists(cache_file):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">with</span> open(cache_file, <span style="color:#e6db74">&#39;r&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>                cache_dict <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">save_cache</span>():
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">with</span> open(cache_file, <span style="color:#e6db74">&#39;w&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>                json<span style="color:#f92672">.</span>dump(cache_dict, f)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">@wraps</span>(func)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, _bypass_cache<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">nonlocal</span> new_entries
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> _bypass_cache:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">await</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            key <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>dumps((args, sorted((k, v) <span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> kwargs<span style="color:#f92672">.</span>items() <span style="color:#66d9ef">if</span> k <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;_bypass_cache&#39;</span>)), sort_keys<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> key <span style="color:#f92672">in</span> cache_dict:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> cache_dict[key]
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            result <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>            cache_dict[key] <span style="color:#f92672">=</span> result
</span></span><span style="display:flex;"><span>            new_entries <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> new_entries <span style="color:#f92672">&gt;=</span> entries_limit:
</span></span><span style="display:flex;"><span>                save_cache()
</span></span><span style="display:flex;"><span>                new_entries <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> wrapper
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> decorator
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Usage example</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@cache</span>(entries_limit<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">expensive_async_function</span>(x, y):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> asyncio<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)  <span style="color:#75715e"># Simulate an expensive async operation</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Run the async function</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#66d9ef">await</span> expensive_async_function(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>))  <span style="color:#75715e"># Takes 2 seconds</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#66d9ef">await</span> expensive_async_function(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>))  <span style="color:#75715e"># Returns immediately</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#66d9ef">await</span> expensive_async_function(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, _bypass_cache<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>))  <span style="color:#75715e"># Takes 2 seconds again</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>asyncio<span style="color:#f92672">.</span>run(main())
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>We&rsquo;ve built a powerful caching decorator that:</p>
<ol>
<li>Supports both positional and keyword arguments</li>
<li>Persists the cache to a file</li>
<li>Limits the number of cached entries</li>
<li>Allows bypassing the cache when needed</li>
<li>Supports both synchronous and asynchronous functions</li>
</ol>
<p>This decorator can significantly improve the performance of your Python applications by reducing redundant computations. Remember to use it judiciously, as caching isn&rsquo;t always beneficial, especially for functions with rapidly changing outputs or side effects.</p>
<p>Feel free to adapt this decorator to your specific needs, and happy coding!</p>
</section>

  
  
  <footer class="mt-12 flex flex-wrap">
     
    <a
      class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]"
      href="http://localhost:1313/tags/python"
      >python</a
    >
     
    <a
      class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]"
      href="http://localhost:1313/tags/cs"
      >CS</a
    >
    
  </footer>
  

  
  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="http://localhost:1313/posts/are_inhouse_llms_cheaper_than_api/"
      ><span class="mr-1.5">←</span><span>Are inhouse LLMs really cheaper than APIs?</span></a
    >
    
    
  </nav>
  
  

  
  

  
  

  
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="http://localhost:1313/">bhuv&#39;s notebook</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >✎ Written in Hugo️️</a
  >️









  </body>
</html>
